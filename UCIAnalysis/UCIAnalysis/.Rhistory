whiteWineData <- read.csv("d:\GitHub\Data\Dane\wine-quality\winequality-white.csv", header = TRUE, sep = ";", dec = ".")
whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".")
whiteWineData
cor(whiteWineData, use = "complete.obs", method = "kendall")
rcorr(whiteWineData, type = "pearson")
library(Hmisc)
plot(whiteWineData$alcohol, whiteWineData$quality)
age <- c(1, 3, 5, 2, 11, 9, 3, 9, 12, 3)
age <- c(1, 3, 5, 2, 11, 9, 3, 9, 12, 3)
weight <- c(4.4, 5.3, 7.2, 5.2, 8.5, 7.3, 6.0, 10.4, 10.2, 6.1)
mean(weight)
sd(weight)
plot(age, weight)
cor(age, weight)
library(Hmisc) whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") redWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-red.csv", header = TRUE, sep = ";", dec = ".")
whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") redWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-red.csv", header = TRUE, sep = ";", dec = ".")
options()
options(digits = 3)
x <- runif(20)
x
runif(1)
runif(1)
runif(1)
runif(1)
runif(100)
c1 <- c(runif(100))
c2 <- c(runif(100))
cor(c1,c2)
c1 <- c(runif(100))
c2 <- c(runif(100))
cor(c1,c2)
plot(c1,c2)
dc <- data.frame(c1,c2)
cor(dc, use = "complete.obs", method = "kendall")
cor(c1,c2)
pdf("w:/filename.pdf")
install.package("pdf")
install.packages("pdf")
p = pdf("w:/filename.pdf", width=7, height=7)
p = pdf("d:/filename.pdf", width=7, height=7)
plot(c1,c2)
def.off()
dev.off()
whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".")
whiteWineData[1..10,]
1..10
c(1..10)
1:10
whiteWineData[1:10,]
(2000*1.78+1000*1.73)/3000
whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".")
plot(whiteWineData$alcohol, whiteWineData$quality)
whiteWineData[1:10,]
whiteWineData[1:10,]
cor(whiteWineData, use = "complete.obs", method = "kendall")
whiteWineDataCopy <- whiteWineData
whiteWineData$fixed.acidity.ln <- ln(whiteWineData$fixed.acidity)
whiteWineData$fixed.acidity.ln <- log(whiteWineData$fixed.acidity)
whiteWineData$volatile.acidity.ln <- log(whiteWineData$volatile.acidity)
whiteWineData$citric.acid.ln <- log(whiteWineData$citric.acid)
whiteWineData$residual.sugar.ln <- log(whiteWineData$residual.sugar)
whiteWineData$chlorides.ln <- log(whiteWineData$chlorides)
whiteWineData$free.sulfur.dioxide.ln <- log(whiteWineData$free.sulfur.dioxide)
whiteWineData$total.sulfur.dioxide.ln <- log(whiteWineData$total.sulfur.dioxide)
whiteWineData$density.ln <- log(whiteWineData$density)
whiteWineData$pH.ln <- log(whiteWineData$pH)
whiteWineData$sulphates.ln <- log(whiteWineData$sulphates)
whiteWineData$alcohol.ln <- log(whiteWineData$alcohol)
whiteWineData$quality.ln <- log(whiteWineData$quality)
cor(whiteWineData, use = "complete.obs", method = "kendall")
whiteWineData[1:10,]
x1 <- c(1,2,3,4,5,6,7,8,9,10)
x2 <- C(1,2,4,8,16,32,64,128,256,512)
x2 <- c(1,2,4,8,16,32,64,128,256,512)
corTest <- data.frame(x1,x2)
cor(corTest, use = "complete.obs", method = "kendall")
corTest$xlog <- log(corTest$x2)
corTest
cor(corTest, use = "complete.obs", method = "kendall")
#library(Hmisc) whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData calculateLogs <- function(dataFrame) {     for (n in names(dataFrame)) {         dataFrame$paste(n, 'log', sep = ".") <- log(dataFrame$n)     } } whiteWineDataWithLogs <- calculateLogs(whiteWineData)
calculateLogs <- function(dataFrame) {     for (n in names(dataFrame)) {         print(dataFrame$n)         dataFrame$paste(n, 'log', sep = ".") <- log(dataFrame$n)     } }
whiteWineDataWithLogs <- calculateLogs(whiteWineData)
calculateLogs <- function(dataFrame) {     for (n in names(dataFrame)) {         print(n)         print(dataFrame$n)         dataFrame$paste(n, 'log', sep = ".") <- log(dataFrame$n)     } }
whiteWineDataWithLogs <- calculateLogs(whiteWineData)
calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])     } }
whiteWineDataWithLogs <- calculateLogs(whiteWineData)
whiteWineDataWithLogs[1:10,]
calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])     }     dataFrame } whiteWineDataWithLogs <- calculateLogs(whiteWineData)
whiteWineDataWithLogs[1:10,]
"a" > "b"
"a" < "b"
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     fname <- c()     sname <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 break             }         }     } }
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     fname <- c()     sname <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 print(currentModel)                 break             }         }     } }
whiteWineDataWithLogs <- calculateLogs(whiteWineData)
calculateRegression(whiteWineDataWithLogs)
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     fname <- c()     sname <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 dataFrame[[n1]]                 currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 print(currentModel)                 break             }         }     } } calculateRegression(whiteWineDataWithLogs)
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     fname <- c()     sname <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 print(currentModel)                 break             }         }     } }
calculateRegression(whiteWineDataWithLogs)
#library(Hmisc) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])     }     dataFrame } whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     fname <- c()     sname <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 print(currentModel)                 break             }         }     } } calculateRegression(whiteWineDataWithLogs)
#library(Hmisc) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])     }     dataFrame } whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     fname <- c()     sname <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 print(currentModel)                 break             }         }     } }
rcorr(whiteWineDataWithLogs, type = "pearson")
library(Hmisc)
instal.packages("Hmisc")
install.packages("Hmisc")
library(Hmisc)
rcorr(whiteWineDataWithLogs, type = "pearson")
typeof(whiteWineDataWithLogs)
typeof(whiteWineData)
xxx <- data.frame()
typeof(xxx)
rcorr(as.matrix(whiteWineDataWithLogs), type = "pearson")
as.matrix(whiteWineDataWithLogs)
getOption("max.print")
setOption("max.print", 999)
oldOp <- options()
options("max.print", 999)
options(max.print=999)
getOption("max.print")
whiteWineDataWithLogsMatrixc <- as.matrix(whiteWineDataWithLogs)
rcorr(whiteWineDataWithLogsMatrixc, type = "pearson")
rown(whiteWineDataWithLogs)
nrow(whiteWineDataWithLogs)
whiteWineDataWithLogs[1:10]
whiteWineDataWithLogs[1:10,0]
whiteWineDataWithLogs[1:10,]
ncol(whiteWineDataWithLogs)
nrow(whiteWineDataWithLogs)
which(is.na(whiteWineDataWithLogs))
whiteWineDataWithLogsFiltered <- whiteWineDataWithLogsFiltered[complete.cases(whiteWineDataWithLogsFiltered),]
whiteWineDataWithLogsFiltered <- whiteWineDataWithLogsFiltered[complete.cases(whiteWineDataWithLogs),]
whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),]
whiteWineDataWithLogsMatrix <- as.matrix(whiteWineDataWithLogsFiltered)
rcorr(whiteWineDataWithLogsMatrix, type = "pearson")
nrow(whiteWineDataWithLogsMatrix)
nrow(whiteWineDataWithLogs)
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     fname <- c()     sname <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(Var$D.Prime, Var$T.statistics, method = "pearson")                 print(currentModel)                 break             }         }     } }
calculateRegression(whiteWineDataWithLogs)
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     fname <- c()     sname <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 print(currentModel)                 break             }         }     } }
calculateRegression(whiteWineDataWithLogs)
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     fname <- c()     sname <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 singleRes <- list(n1, n2, currentModel)                 break             }         }     } }
calculateRegression(whiteWineDataWithLogs)
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     results <- list()     index <- 1     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 singleRes <- list(n1, n2, currentModel)                 results[[index]] <- singleRes                 index <- index + 1                 break             }         }     }     results }
regRes <- calculateRegression(whiteWineDataWithLogs)
regRes
regRes[[1]]
regRes[[1]][[1]]
regRes[[1]][[2]]
regRes[[1]][[3]]
m1 <- regRes[[1]][[3]]
names(m1)
regRes[[1]][[3]]$conf.int
regRes[[1]][[3]]$p.value
regRes[[1]][[3]]$cor
regRes[[1]][[3]]$statistic
regRes[[1]][[3]]$statistic
library(Hmisc) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])     }     dataFrame } whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     results <- list()     index <- 1     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 singleRes <- list(n1, n2, currentModel)                 results[[index]] <- singleRes                 index <- index + 1                 break             }         }     }     results }
oldOp <- options() options(max.print = 999)
oldOp <- options() options(max.print = 999) whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] whiteWineDataWithLogsMatrix <- as.matrix(whiteWineDataWithLogsFiltered) regRes <- calculateRegression(whiteWineDataWithLogs)
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     results <- list()     index <- 1     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1))                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 singleRes <- list(n1, n2, currentModel)                 results[[index]] <- singleRes                 index <- index + 1             }         }     }     results }
oldOp <- options() options(max.print = 999) whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] whiteWineDataWithLogsMatrix <- as.matrix(whiteWineDataWithLogsFiltered) regRes <- calculateRegression(whiteWineDataWithLogs)
library(Hmisc) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])     }     dataFrame } whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     results <- list()     index <- 1     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1))                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 singleRes <- list(n1, n2, currentModel)                 results[[index]] <- singleRes                 index <- index + 1             }         }     }     print(index)     results } oldOp <- options() options(max.print = 999) whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] whiteWineDataWithLogsMatrix <- as.matrix(whiteWineDataWithLogsFiltered) regRes <- calculateRegression(whiteWineDataWithLogs)
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     results <- list()     index <- 1     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     singleRes <- list(n1, n2, currentModel)                     results[[index]] <- singleRes                     index <- index + 1                 }             }         }     }     print(index)     results }
whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] whiteWineDataWithLogsMatrix <- as.matrix(whiteWineDataWithLogsFiltered) regRes <- calculateRegression(whiteWineDataWithLogs)
length(regRes)
regRes[[1]]
regRes[[1]][[1]]
regRes[[1]][[2]]
regRes[[1]][[3]]
regRes[[1]][[3]][[1]]
regRes[[1]][[3]][[2]]
regRes[[1]][[3]][[3]]
regRes[[1]][[3]][[4]]
names(regRes[[1]][[3]])
regRes[[1]][[3]]$cor
regRes[[1]][[3]][[4]]
regRes[[1]][[3]]$p.value
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     #results <- list()     index <- 1     names1 <- list()     names2 <- list()     corrValues <- list()     pValues <- list()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     #singleRes <- list(n1, n2, currentModel)                     #results[[index]] <- singleRes                     names1[[index]] <- n1                     names2[[index]] <- n2                     corrValues[[index]] <- currentModel[[4]]                     pValues[[index]] <- currentModel$p.value                     index <- index + 1                 }             }         }     }     #print(index)     results = data.frame(names1, names2, corrValues, pValues)     results }
regRes <- calculateRegression(whiteWineDataWithLogs)
regRes
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     #results <- list()     index <- 1     names1 <- list()     names2 <- list()     corrValues <- list()     pValues <- list()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     #singleRes <- list(n1, n2, currentModel)                     #results[[index]] <- singleRes                     names1[[index]] <- n1                     names2[[index]] <- n2                     corrValues[[index]] <- currentModel[[4]]                     pValues[[index]] <- currentModel$p.value                     index <- index + 1                 }             }         }     }     #print(index)     results = data.frame(c(names1), c(names2), c(corrValues), c(pValues))     results }
regRes <- calculateRegression(whiteWineDataWithLogs)
nrow(regRes)
regRes
c1 <- c(1,2,3)
c2 <- c("a", "b", "c")
data.frame(c1,c2)
whiteWineDataWithLogsMatrix
whiteWineDataWithLogsMatrix[[1]]
whiteWineDataWithLogsMatrix[[]]
whiteWineDataWithLogsMatrix[[3]]
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     #results <- list()     index <- 1     names1 <- list()     names2 <- list()     corrValues <- list()     pValues <- list()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     #singleRes <- list(n1, n2, currentModel)                     #results[[index]] <- singleRes                     #names1[[index]] <- append(n1, names1)                     names1 <- append(n1, names1)                     names2[[index]] <- n2                     corrValues[[index]] <- currentModel[[4]]                     pValues[[index]] <- currentModel$p.value                     index <- index + 1                 }             }         }     }     names1     #print(index)     results = data.frame(c(names1), c(names2), c(corrValues), c(pValues))     results }
regRes <- calculateRegression(whiteWineDataWithLogs)
regRes
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     #results <- list()     index <- 1     names1 <- list()     names2 <- list()     corrValues <- list()     pValues <- list()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     #singleRes <- list(n1, n2, currentModel)                     #results[[index]] <- singleRes                     #names1[[index]] <- append(n1, names1)                     names1 <- append(n1, names1)                     names2[[index]] <- n2                     corrValues[[index]] <- currentModel[[4]]                     pValues[[index]] <- currentModel$p.value                     index <- index + 1                 }             }         }     }     names1     #print(index)     #results = data.frame(c(names1), c(names2), c(corrValues), c(pValues))     #results }
regRes <- calculateRegression(whiteWineDataWithLogs)
regRes
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     #results <- list()     index <- 1     names1 <- c()     names2 <- list()     corrValues <- list()     pValues <- list()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     #singleRes <- list(n1, n2, currentModel)                     #results[[index]] <- singleRes                     #names1[[index]] <- append(n1, names1)                     names1 <- append(names1, n1)                     names2[[index]] <- n2                     corrValues[[index]] <- currentModel[[4]]                     pValues[[index]] <- currentModel$p.value                     index <- index + 1                 }             }         }     }     names1     #print(index)     #results = data.frame(c(names1), c(names2), c(corrValues), c(pValues))     #results }
regRes <- calculateRegression(whiteWineDataWithLogs)
regRes
calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     #results <- list()     index <- 1     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     #singleRes <- list(n1, n2, currentModel)                     #results[[index]] <- singleRes                     names1 <- append(names1, n1)                     names2 <- append(names2, n2)                     corrValues <- append(corrValues, currentModel[[4]])                     pValues <- append(pValues, currentModel$p.value)                     #corrValues[[index]] <- currentModel[[4]]                     #pValues[[index]] <- currentModel$p.value                     index <- index + 1                 }             }         }     }     #names1     #print(index)     results = data.frame(names1, names2, corrValues, pValues)     results }
oldOp <- options() options(max.print = 999) whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] whiteWineDataWithLogsMatrix <- as.matrix(whiteWineDataWithLogsFiltered)
regRes <- calculateRegression(whiteWineDataWithLogs)
regRes
regResFiletered <- regRes[complete.cases(regRes),]
regResFiletered
complete.cases(regRes)
length(regResFiletered)
nrow(regResFiletered)
regResFiletered
regResFiletered[regResFiletered$corrValu]
regResFiletered[abs(regResFiletered$corrValues) >= 0.3]
regResFiletered[abs(regResFiletered$corrValues) >= 0.3,]
regResFiletered[startsWith(regResFiletered$n1, "quality") || startsWith(regResFiletered$n2, "quality"),]
regResFiletered[startsWith(regResFiletered$names1, "quality") || startsWith(regResFiletered$names2, "quality"),]
regResFiletered$names1
startsWith(regResFiletered$names1, "fd")
regResFiletered[abs(regResFiletered$corrValues) >= 0.3,]
regResFiletered[regResFiletered$names1 == "quality" || regResFiletered$names2 == "quality",]
regResFiletered[(regResFiletered$names1 == "quality") || (regResFiletered$names2 == "quality"),]
regResFiletered
regResFiletered
library(Hmisc) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])     }     dataFrame } whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     names1 <- append(names1, n1)                     names2 <- append(names2, n2)                     corrValues <- append(corrValues, currentModel[[4]])                     pValues <- append(pValues, currentModel$p.value)                 }             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results }
oldOp <- options() options(max.print = 999) whiteWineDataCopy <- whiteWineData whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] whiteWineDataWithLogsMatrix <- as.matrix(whiteWineDataWithLogsFiltered) regRes <- calculateRegression(whiteWineDataWithLogs) regResFiletered <- regRes[complete.cases(regRes),]
regResFiletered
library(Hmisc) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])     }     dataFrame } whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     names1 <- append(names1, n1)                     names2 <- append(names2, n2)                     corrValues <- append(corrValues, currentModel[[4]])                     pValues <- append(pValues, currentModel$p.value)                 }             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results } oldOp <- options() options(max.print = 999) whiteWineDataCopy <- whiteWineData whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] whiteWineDataWithLogsMatrix <- as.matrix(whiteWineDataWithLogsFiltered) regRes <- calculateRegression(whiteWineDataWithLogs) regResFiletered <- regRes[complete.cases(regRes),] regResFiletered[abs(regResFiletered$corrValues) >= 0.3,]
regResFiletered[regResFiletered$names1 == "quality",]
regResFiletered[(regResFiletered$names1 == "quality") || (regResFiletered$names2 == "quality"),]
regResFiletered[(regResFiletered$names1 == "quality") or (regResFiletered$names2 == "quality"),]
regResFiletered[((regResFiletered$names1 == "quality") || (regResFiletered$names2 == "quality")),]
regResFiletered$names1 == "quality"
regResFiletered$names2 == "quality"
((regResFiletered$names1 == "quality") || (regResFiletered$names2 == "quality"))
regResFiletered[((regResFiletered$names1 == "quality") | (regResFiletered$names2 == "quality")),]
regResFiletered[((regResFiletered$names1 == "quality") | (regResFiletered$names2 == "quality") | (regResFiletered$names1 == "quality.log") | (regResFiletered$names2 == "quality.log")),]
help endsWith
help("endsWith")
help("endsWith")
help("exp")
library(Hmisc) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") || !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])         }     }     dataFrame } calculateExps <- function(dataFrame) {     print("[calculateExps]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") || !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'exp', sep = ".")]] <- exp(dataFrame[[n]])         }     }     dataFrame } whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) whiteWineDataWithLogs <- calculateExps(whiteWineDataWithLogs) calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     names1 <- append(names1, n1)                     names2 <- append(names2, n2)                     corrValues <- append(corrValues, currentModel[[4]])                     pValues <- append(pValues, currentModel$p.value)                 }             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results } calculateRegressionWithQuality <- function(dataFrame) {     print("[calculateRegressionWithQuality]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     qualityNames <- c("quality", "quality.log", "quality.exp")     for (n1 in names(dataFrame)) {         for (n2 in qualityNames) {             if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 names1 <- append(names1, n1)                 names2 <- append(names2, n2)                 corrValues <- append(corrValues, currentModel[[4]])                 pValues <- append(pValues, currentModel$p.value)             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results }
oldOp <- options() options(max.print = 999)
whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),]
whiteWineDataWithLogsFiltered
regRes2 <- calculateRegressionWithQuality(whiteWineDataWithLogs)
regRes2Filetered <- regRes[complete.cases(regRes2),]
regResFiletered
regRes2Filetered <- regRes2[complete.cases(regRes2),]
regRes2Filetered
library(Hmisc) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])         }     }     dataFrame } calculateExps <- function(dataFrame) {     print("[calculateExps]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'exp', sep = ".")]] <- exp(dataFrame[[n]])         }     }     dataFrame } calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     names1 <- append(names1, n1)                     names2 <- append(names2, n2)                     corrValues <- append(corrValues, currentModel[[4]])                     pValues <- append(pValues, currentModel$p.value)                 }             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results } calculateRegressionWithQuality <- function(dataFrame) {     print("[calculateRegressionWithQuality]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     qualityNames <- c("quality", "quality.log", "quality.exp")     for (n1 in names(dataFrame)) {         for (n2 in qualityNames) {             if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 names1 <- append(names1, n1)                 names2 <- append(names2, n2)                 corrValues <- append(corrValues, currentModel[[4]])                 pValues <- append(pValues, currentModel$p.value)             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results }
oldOp <- options() options(max.print = 999) whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) whiteWineDataWithLogs <- calculateExps(whiteWineDataWithLogs) whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),]
regRes2 <- calculateRegressionWithQuality(whiteWineDataWithLogs)
regRes2Filetered <- regRes2[complete.cases(regRes2),]
regRes2Filetered
regRes2Filetered[(regRes2Filetered$names2 == "quality"),]
library(Hmisc) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])         }     }     dataFrame } calculateExps <- function(dataFrame) {     print("[calculateExps]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'exp', sep = ".")]] <- exp(dataFrame[[n]])         }     }     dataFrame } calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     names1 <- append(names1, n1)                     names2 <- append(names2, n2)                     corrValues <- append(corrValues, currentModel[[4]])                     pValues <- append(pValues, currentModel$p.value)                 }             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results } calculateRegressionWithQuality <- function(dataFrame) {     print("[calculateRegressionWithQuality]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     corrValuesModule <- c()     qualityNames <- c("quality", "quality.log", "quality.exp")     for (n1 in names(dataFrame)) {         for (n2 in qualityNames) {             if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 names1 <- append(names1, n1)                 names2 <- append(names2, n2)                 corrValues <- append(corrValues, currentModel[[4]])                 pValues <- append(pValues, currentModel$p.value)             }         }     }     corrValuesModule <- abs(corrValues)     results = data.frame(names1, names2, corrValues, pValues, corrValuesModule)     results } oldOp <- options() options(max.print = 999) whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) whiteWineDataWithLogs <- calculateExps(whiteWineDataWithLogs) whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] regRes2 <- calculateRegressionWithQuality(whiteWineDataWithLogs) regRes2Filetered <- regRes2[complete.cases(regRes2),] regRes2Filetered[(regRes2Filetered$names2 == "quality"),]
dd[with(dd, order( - z, b)),]regRes2Filetered2 <- regRes2Filetered[(regRes2Filetered$names2 == "quality"),]
regRes2Filetered2 <- regRes2Filetered[(regRes2Filetered$names2 == "quality"),]
regRes2Filetered2[with(regRes2Filetered2, order(corrValuesModule)),]
regRes2FilteredOrdered <- regRes2Filetered2[with(regRes2Filetered2, order(corrValuesModule)),]
regRes2FilteredOrdered
plot(whiteWineData$alcohol, whiteWineData$quality)
plot(whiteWineDataWithLogsFiltered$alcohol, whiteWineDataWithLogsFiltered$density.log)
plot(whiteWineDataWithLogsFiltered$alcohol, whiteWineDataWithLogsFiltered$quality)
plot(whiteWineDataWithLogsFiltered$chlorides.log, whiteWineDataWithLogsFiltered$quality)
library(XML)
install.packages("XML")
library(XML)
doc.html = htmlTreeParse('https://www.rcb.at/produkt/participation/?ID_NOTATION=62781084&ISIN=AT0000A05VT0', useInternal = TRUE)
library(RCurl)
txt <- htmlToText("https://www.rcb.at/produkt/participation/?ID_NOTATION=62781084&ISIN=AT0000A05VT0")
txt <- getURL("https://www.rcb.at/produkt/participation/?ID_NOTATION=62781084&ISIN=AT0000A05VT0")
txt
pos <- regexpr("valueFilter:priceFilter2\">(.+)</span><br/>", txt)
pos
substring(txt,1906, 1906+50)
substring(txt, 24021, 24021 + 50)
pos[[1]]
regexpr("valueFilter:priceFilter2fdsfsdfsd\">(.+)</span><br/>", txt)
regexpr("valueFilter:priceFilter2\">(?<value>.+?)</span><br/>", txt)
regexpr("valueFilter:priceFilter2\">(.+?)</span><br/>", txt)
substring(txt, pos[[1]], pos[[1]] + pos[[2]])
pos <- regexpr("valueFilter:priceFilter2\">(.+?)</span><br/>", txt)
substring(txt, pos[[1]], pos[[1]] + pos[[2]])
pos[[1]]
pos[[2]]
pos[[1]]$match.length
pos$match.length
pos
names(pos)
length(pos)
substring(txt, pos, pos + 100)
substring(txt, pos, pos + 50)
subt <- substring(txt, pos, pos + 100)
subt
subt <- substring(txt, pos, pos + 50)
regexp("</span><br/>", subt)
regexpr("</span><br/>", subt)
subt <- substring(txt, pos + 26, pos + 50)
subt
regexpr("</span><br/>", subt)
pos2<-regexpr("</span><br/>", subt)
substr(subt, 0, pos2)
substr(subt, 0, pos2 - 1)
txtValue <- substr(subt, 0, pos2 - 1)
>strtoi(txtValue)
txtValue <- substr(subt, 0, pos2 - 1)
txtValue
>strtoi(txtValue)
strtoi(txtValue)
gsub(",", ".", txtValue)
valueTxt <- gsub(",", ".", txtValue)
strtoi(valueTxt)
valueTxt
strtoi("1.2")
strtoi("1,2")
strtoi("1,2", base = 10)
strtoi("1.2", base = 10)
as.numeric(valueTxt)
as.numeric(valueTxt)library(Hmisc) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])         }     }     dataFrame } calculateExps <- function(dataFrame) {     print("[calculateExps]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'exp', sep = ".")]] <- exp(dataFrame[[n]])         }     }     dataFrame } calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     names1 <- append(names1, n1)                     names2 <- append(names2, n2)                     corrValues <- append(corrValues, currentModel[[4]])                     pValues <- append(pValues, currentModel$p.value)                 }             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results } calculateRegressionWithQuality <- function(dataFrame) {     print("[calculateRegressionWithQuality]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     corrValuesModule <- c()     qualityNames <- c("quality", "quality.log", "quality.exp")     for (n1 in names(dataFrame)) {         for (n2 in qualityNames) {             if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 names1 <- append(names1, n1)                 names2 <- append(names2, n2)                 corrValues <- append(corrValues, currentModel[[4]])                 pValues <- append(pValues, currentModel$p.value)             }         }     }     corrValuesModule <- abs(corrValues)     results = data.frame(names1, names2, corrValues, pValues, corrValuesModule)     results } oldOp <- options() options(max.print = 999) whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) whiteWineDataWithLogs <- calculateExps(whiteWineDataWithLogs) whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] regRes2 <- calculateRegressionWithQuality(whiteWineDataWithLogs) regRes2Filetered <- regRes2[complete.cases(regRes2),] regRes2Filetered2 <- regRes2Filetered[(regRes2Filetered$names2 == "quality"),] regRes2FilteredOrdered <- regRes2Filetered2[with(regRes2Filetered2, order(corrValuesModule)),]
regRes2FilteredOrdered
lm(formula = quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = whiteWineDataWithLogsFiltered)
regModel <- lm(formula = quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = whiteWineDataWithLogsFiltered)
regModel
regModel <- lm(formula = quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = whiteWineDataWithLogsFiltered)
summary(regModel)
whiteWineDataWithLogsFiltered
splittedData <- splitData(whiteWineDataWithLogsFiltered, 0.7, 123456)
splitData <- function(inputRecords, splitRatio, seedValue) {     ## 75% of the sample size     smp_size <- floor(splitRatio * nrow(inputRecords))     ## set the seed to make your partition reproductible     set.seed(seedValue)     train_ind <- sample(seq_len(nrow(inputRecords)), size = smp_size)     trainData <- inputRecords[train_ind,]     testData <- inputRecords[ - train_ind,]     result <- list()     result[[1]] <- trainData     result[[2]] <- testData }
splittedData <- splitData(whiteWineDataWithLogsFiltered, 0.7, 123456)
print(nrow(splittedData[[1]])) print(nrow(splittedData[[2]]))
splittedData
print(length(splittedData[[1]])) print(length(splittedData[[2]]))
print(nrow(whiteWineDataWithLogsFiltered))
splitData <- function(inputRecords, splitRatio, seedValue) {     print("[splitData]")     ptiny(nrow(inputRecords))     ## 75% of the sample size     smp_size <- floor(splitRatio * nrow(inputRecords))     ## set the seed to make your partition reproductible     set.seed(seedValue)     train_ind <- sample(seq_len(nrow(inputRecords)), size = smp_size)     trainData <- inputRecords[train_ind,]     testData <- inputRecords[ - train_ind,]     result <- list()     result[[1]] <- trainData     result[[2]] <- testData }
splittedData <- splitData(whiteWineDataWithLogsFiltered, 0.7, 123456)
splitData <- function(inputRecords, splitRatio, seedValue) {     print("[splitData]")     print(nrow(inputRecords))     ## 75% of the sample size     smp_size <- floor(splitRatio * nrow(inputRecords))     ## set the seed to make your partition reproductible     set.seed(seedValue)     train_ind <- sample(seq_len(nrow(inputRecords)), size = smp_size)     trainData <- inputRecords[train_ind,]     testData <- inputRecords[ - train_ind,]     result <- list()     result[[1]] <- trainData     result[[2]] <- testData }
splittedData <- splitData(whiteWineDataWithLogsFiltered, 0.7, 123456)
splitData <- function(inputRecords, splitRatio, seedValue) {     print("[splitData]")     print(nrow(inputRecords))     ## 75% of the sample size     smp_size <- floor(splitRatio * nrow(inputRecords))     ## set the seed to make your partition reproductible     set.seed(seedValue)     train_ind <- sample(seq_len(nrow(inputRecords)), size = smp_size)     trainData <- inputRecords[train_ind,]     testData <- inputRecords[ - train_ind,]     result <- list()     result[[1]] <- trainData     result[[2]] <- testData     result }
splittedData <- splitData(whiteWineDataWithLogsFiltered, 0.7, 123456)
print(length(splittedData[[1]])) print(length(splittedData[[2]]))
print(nrow(whiteWineDataWithLogsFiltered))
splittedData
print(nrow(splittedData[[1]])) print(nrow(splittedData[[2]]))
splittedData <- splitData(whiteWineDataWithLogsFiltered, 0.7, 123456) print(nrow(splittedData[[1]])) print(nrow(splittedData[[2]])) print(nrow(whiteWineDataWithLogsFiltered))
splittedData <- splitData(whiteWineDataWithLogsFiltered, 0.7, 123456) print(nrow(splittedData[[1]])) print(nrow(splittedData[[2]])) print(nrow(whiteWineDataWithLogsFiltered)) trainingData <- splittedData[[1]] testData <- splittedData[[2]] regModel <- lm(formula = quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData)
predict(regModel, testData, interval = "confidence")
predict(regModel, testData, interval = "confidence")
testData
library(Hmisc) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])         }     }     dataFrame } calculateExps <- function(dataFrame) {     print("[calculateExps]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'exp', sep = ".")]] <- exp(dataFrame[[n]])         }     }     dataFrame } calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     names1 <- append(names1, n1)                     names2 <- append(names2, n2)                     corrValues <- append(corrValues, currentModel[[4]])                     pValues <- append(pValues, currentModel$p.value)                 }             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results } splitData <- function(inputRecords, splitRatio, seedValue) {     print("[splitData]")     print(nrow(inputRecords))     ## 75% of the sample size     smp_size <- floor(splitRatio * nrow(inputRecords))     ## set the seed to make your partition reproductible     set.seed(seedValue)     train_ind <- sample(seq_len(nrow(inputRecords)), size = smp_size)     trainData <- inputRecords[train_ind,]     testData <- inputRecords[ - train_ind,]     result <- list()     result[[1]] <- trainData     result[[2]] <- testData     result } calculateRegressionWithQuality <- function(dataFrame) {     print("[calculateRegressionWithQuality]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     corrValuesModule <- c()     qualityNames <- c("quality", "quality.log", "quality.exp")     for (n1 in names(dataFrame)) {         for (n2 in qualityNames) {             if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 names1 <- append(names1, n1)                 names2 <- append(names2, n2)                 corrValues <- append(corrValues, currentModel[[4]])                 pValues <- append(pValues, currentModel$p.value)             }         }     }     corrValuesModule <- abs(corrValues)     results = data.frame(names1, names2, corrValues, pValues, corrValuesModule)     results } oldOp <- options() options(max.print = 999) whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) whiteWineDataWithLogs <- calculateExps(whiteWineDataWithLogs) whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] splittedData <- splitData(whiteWineDataWithLogsFiltered, 0.7, 123456) print(nrow(splittedData[[1]])) print(nrow(splittedData[[2]])) print(nrow(whiteWineDataWithLogsFiltered)) trainingData <- splittedData[[1]] testData <- splittedData[[2]] regModel <- lm(formula = quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData) regRes2 <- calculateRegressionWithQuality(whiteWineDataWithLogs) regRes2Filetered <- regRes2[complete.cases(regRes2),] regRes2Filetered2 <- regRes2Filetered[(regRes2Filetered$names2 == "quality"),] regRes2FilteredOrdered <- regRes2Filetered2[with(regRes2Filetered2, order(corrValuesModule)),] #alcohol + #density.log - #chlorides.log - #volatile.acidity.log - #total.sulfur.dioxide - #fixed.acidity - predictedData <- predict(regModel, testData, interval = "confidence")
testData
testDataWithPrediction[1,]
predictedData[1,]
predictedData
predictedData[1, 1]
testDataWithPrediction <- merge(testData, predictedData)
nrow(testDataWithPrediction)
testDataWithPrediction <- NULL
library(Hmisc) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])         }     }     dataFrame } calculateExps <- function(dataFrame) {     print("[calculateExps]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'exp', sep = ".")]] <- exp(dataFrame[[n]])         }     }     dataFrame } calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     names1 <- append(names1, n1)                     names2 <- append(names2, n2)                     corrValues <- append(corrValues, currentModel[[4]])                     pValues <- append(pValues, currentModel$p.value)                 }             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results } splitData <- function(inputRecords, splitRatio, seedValue) {     print("[splitData]")     print(nrow(inputRecords))     ## 75% of the sample size     smp_size <- floor(splitRatio * nrow(inputRecords))     ## set the seed to make your partition reproductible     set.seed(seedValue)     train_ind <- sample(seq_len(nrow(inputRecords)), size = smp_size)     trainData <- inputRecords[train_ind,]     testData <- inputRecords[ - train_ind,]     result <- list()     result[[1]] <- trainData     result[[2]] <- testData     result } calculateRegressionWithQuality <- function(dataFrame) {     print("[calculateRegressionWithQuality]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     corrValuesModule <- c()     qualityNames <- c("quality", "quality.log", "quality.exp")     for (n1 in names(dataFrame)) {         for (n2 in qualityNames) {             if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 names1 <- append(names1, n1)                 names2 <- append(names2, n2)                 corrValues <- append(corrValues, currentModel[[4]])                 pValues <- append(pValues, currentModel$p.value)             }         }     }     corrValuesModule <- abs(corrValues)     results = data.frame(names1, names2, corrValues, pValues, corrValuesModule)     results } oldOp <- options() options(max.print = 999) whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineData$ID <- seq.int(nrow(whiteWineData)) whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) whiteWineDataWithLogs <- calculateExps(whiteWineDataWithLogs) whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] splittedData <- splitData(whiteWineDataWithLogsFiltered, 0.7, 123456) print(nrow(splittedData[[1]])) print(nrow(splittedData[[2]])) print(nrow(whiteWineDataWithLogsFiltered)) trainingData <- splittedData[[1]] testData <- splittedData[[2]] regModel <- lm(formula = quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData) regRes2 <- calculateRegressionWithQuality(whiteWineDataWithLogs) regRes2Filetered <- regRes2[complete.cases(regRes2),] regRes2Filetered2 <- regRes2Filetered[(regRes2Filetered$names2 == "quality"),] regRes2FilteredOrdered <- regRes2Filetered2[with(regRes2Filetered2, order(corrValuesModule)),] #alcohol + #density.log - #chlorides.log - #volatile.acidity.log - #total.sulfur.dioxide - #fixed.acidity - predictedData <- predict(regModel, testData, interval = "confidence") testDataWithPrediction <- merge(testData, predictedData)
testDataWithPrediction
library(Hmisc) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])         }     }     dataFrame } calculateExps <- function(dataFrame) {     print("[calculateExps]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'exp', sep = ".")]] <- exp(dataFrame[[n]])         }     }     dataFrame } calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     names1 <- append(names1, n1)                     names2 <- append(names2, n2)                     corrValues <- append(corrValues, currentModel[[4]])                     pValues <- append(pValues, currentModel$p.value)                 }             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results } splitData <- function(inputRecords, splitRatio, seedValue) {     print("[splitData]")     print(nrow(inputRecords))     ## 75% of the sample size     smp_size <- floor(splitRatio * nrow(inputRecords))     ## set the seed to make your partition reproductible     set.seed(seedValue)     train_ind <- sample(seq_len(nrow(inputRecords)), size = smp_size)     trainData <- inputRecords[train_ind,]     testData <- inputRecords[ - train_ind,]     result <- list()     result[[1]] <- trainData     result[[2]] <- testData     result } calculateRegressionWithQuality <- function(dataFrame) {     print("[calculateRegressionWithQuality]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     corrValuesModule <- c()     qualityNames <- c("quality", "quality.log", "quality.exp")     for (n1 in names(dataFrame)) {         for (n2 in qualityNames) {             if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 names1 <- append(names1, n1)                 names2 <- append(names2, n2)                 corrValues <- append(corrValues, currentModel[[4]])                 pValues <- append(pValues, currentModel$p.value)             }         }     }     corrValuesModule <- abs(corrValues)     results = data.frame(names1, names2, corrValues, pValues, corrValuesModule)     results } oldOp <- options() options(max.print = 999) whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineData$ID <- seq.int(nrow(whiteWineData)) whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) whiteWineDataWithLogs <- calculateExps(whiteWineDataWithLogs) whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] splittedData <- splitData(whiteWineDataWithLogsFiltered, 0.7, 123456) print(nrow(splittedData[[1]])) print(nrow(splittedData[[2]])) print(nrow(whiteWineDataWithLogsFiltered)) trainingData <- splittedData[[1]] testData <- splittedData[[2]] regModel <- lm(formula = quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData) regRes2 <- calculateRegressionWithQuality(whiteWineDataWithLogs) regRes2Filetered <- regRes2[complete.cases(regRes2),] regRes2Filetered2 <- regRes2Filetered[(regRes2Filetered$names2 == "quality"),] regRes2FilteredOrdered <- regRes2Filetered2[with(regRes2Filetered2, order(corrValuesModule)),] #alcohol + #density.log - #chlorides.log - #volatile.acidity.log - #total.sulfur.dioxide - #fixed.acidity - predictedData <- predict(regModel, testData, interval = "confidence") testDataWithPrediction <- merge(testData, predictedData)
testDataWithPrediction
library(Hmisc) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])         }     }     dataFrame } calculateExps <- function(dataFrame) {     print("[calculateExps]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'exp', sep = ".")]] <- exp(dataFrame[[n]])         }     }     dataFrame } calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     names1 <- append(names1, n1)                     names2 <- append(names2, n2)                     corrValues <- append(corrValues, currentModel[[4]])                     pValues <- append(pValues, currentModel$p.value)                 }             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results } splitData <- function(inputRecords, splitRatio, seedValue) {     print("[splitData]")     print(nrow(inputRecords))     ## 75% of the sample size     smp_size <- floor(splitRatio * nrow(inputRecords))     ## set the seed to make your partition reproductible     set.seed(seedValue)     train_ind <- sample(seq_len(nrow(inputRecords)), size = smp_size)     trainData <- inputRecords[train_ind,]     testData <- inputRecords[ - train_ind,]     result <- list()     result[[1]] <- trainData     result[[2]] <- testData     result } calculateRegressionWithQuality <- function(dataFrame) {     print("[calculateRegressionWithQuality]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     corrValuesModule <- c()     qualityNames <- c("quality", "quality.log", "quality.exp")     for (n1 in names(dataFrame)) {         for (n2 in qualityNames) {             if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 names1 <- append(names1, n1)                 names2 <- append(names2, n2)                 corrValues <- append(corrValues, currentModel[[4]])                 pValues <- append(pValues, currentModel$p.value)             }         }     }     corrValuesModule <- abs(corrValues)     results = data.frame(names1, names2, corrValues, pValues, corrValuesModule)     results } oldOp <- options() options(max.print = 999) whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineData$ID <- seq.int(nrow(whiteWineData)) whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) whiteWineDataWithLogs <- calculateExps(whiteWineDataWithLogs) whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] splittedData <- splitData(whiteWineDataWithLogsFiltered, 0.7, 123456) print(nrow(splittedData[[1]])) print(nrow(splittedData[[2]])) print(nrow(whiteWineDataWithLogsFiltered)) trainingData <- splittedData[[1]] testData <- splittedData[[2]] regModel <- lm(formula = quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData) regRes2 <- calculateRegressionWithQuality(whiteWineDataWithLogs) regRes2Filetered <- regRes2[complete.cases(regRes2),] regRes2Filetered2 <- regRes2Filetered[(regRes2Filetered$names2 == "quality"),] regRes2FilteredOrdered <- regRes2Filetered2[with(regRes2Filetered2, order(corrValuesModule)),] #alcohol + #density.log - #chlorides.log - #volatile.acidity.log - #total.sulfur.dioxide - #fixed.acidity - predictedData <- predict(regModel, testData, interval = "confidence") testDataWithPrediction <- merge(testData, predictedData, by = "ID")
predictedData
testData
whiteWineData
testData
library(Hmisc) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])         }     }     dataFrame } calculateExps <- function(dataFrame) {     print("[calculateExps]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'exp', sep = ".")]] <- exp(dataFrame[[n]])         }     }     dataFrame } calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     names1 <- append(names1, n1)                     names2 <- append(names2, n2)                     corrValues <- append(corrValues, currentModel[[4]])                     pValues <- append(pValues, currentModel$p.value)                 }             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results } splitData <- function(inputRecords, splitRatio, seedValue) {     print("[splitData]")     print(nrow(inputRecords))     ## 75% of the sample size     smp_size <- floor(splitRatio * nrow(inputRecords))     ## set the seed to make your partition reproductible     set.seed(seedValue)     train_ind <- sample(seq_len(nrow(inputRecords)), size = smp_size)     trainData <- inputRecords[train_ind,]     testData <- inputRecords[ - train_ind,]     result <- list()     result[[1]] <- trainData     result[[2]] <- testData     result } calculateRegressionWithQuality <- function(dataFrame) {     print("[calculateRegressionWithQuality]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     corrValuesModule <- c()     qualityNames <- c("quality", "quality.log", "quality.exp")     for (n1 in names(dataFrame)) {         for (n2 in qualityNames) {             if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 names1 <- append(names1, n1)                 names2 <- append(names2, n2)                 corrValues <- append(corrValues, currentModel[[4]])                 pValues <- append(pValues, currentModel$p.value)             }         }     }     corrValuesModule <- abs(corrValues)     results = data.frame(names1, names2, corrValues, pValues, corrValuesModule)     results } oldOp <- options() options(max.print = 999) whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) whiteWineDataWithLogs <- calculateExps(whiteWineDataWithLogs) whiteWineData$ID <- seq.int(nrow(whiteWineData)) whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] splittedData <- splitData(whiteWineDataWithLogsFiltered, 0.7, 123456) print(nrow(splittedData[[1]])) print(nrow(splittedData[[2]])) print(nrow(whiteWineDataWithLogsFiltered)) trainingData <- splittedData[[1]] testData <- splittedData[[2]] regModel <- lm(formula = quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData) regRes2 <- calculateRegressionWithQuality(whiteWineDataWithLogs) regRes2Filetered <- regRes2[complete.cases(regRes2),] regRes2Filetered2 <- regRes2Filetered[(regRes2Filetered$names2 == "quality"),] regRes2FilteredOrdered <- regRes2Filetered2[with(regRes2Filetered2, order(corrValuesModule)),] #alcohol + #density.log - #chlorides.log - #volatile.acidity.log - #total.sulfur.dioxide - #fixed.acidity - predictedData <- predict(regModel, testData, interval = "confidence") testDataWithPrediction <- merge(testData, predictedData, by = "ID")
fitted(regModel)
nrowfittedData <- fitted(regModel)
fittedData <- fitted(regModel)
nrow(fittedData)
length(fittedData)
fittedData[[1]]
names(fittedData)
fittedData["3908"]
testData$predicted <- predict(regModel, testData, interval = "confidence")
testData
treeModel <- ctree(quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData)
library("party")
library(party)
install.packages("party")
library(party)
treeModel <- ctree(quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData)
print(treeModel)
plot(treeModel)print(treeModel)
plot(treeModel)
c1 <- c(1, 2, 3, 5)
c2 <- c(1, 3, 3, 5)
c1 - c2
c3 <- c1 - c2 c3
c3[c3==0]
length(c3[c3 == 0])
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData, interval = "confidence")     if (NULL != transformationFunction) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
library(Hmisc) library(party) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])         }     }     dataFrame } calculateExps <- function(dataFrame) {     print("[calculateExps]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'exp', sep = ".")]] <- exp(dataFrame[[n]])         }     }     dataFrame } calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     names1 <- append(names1, n1)                     names2 <- append(names2, n2)                     corrValues <- append(corrValues, currentModel[[4]])                     pValues <- append(pValues, currentModel$p.value)                 }             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results } splitData <- function(inputRecords, splitRatio, seedValue) {     print("[splitData]")     print(nrow(inputRecords))     ## 75% of the sample size     smp_size <- floor(splitRatio * nrow(inputRecords))     ## set the seed to make your partition reproductible     set.seed(seedValue)     train_ind <- sample(seq_len(nrow(inputRecords)), size = smp_size)     trainData <- inputRecords[train_ind,]     testData <- inputRecords[ - train_ind,]     result <- list()     result[[1]] <- trainData     result[[2]] <- testData     result } calculateRegressionWithQuality <- function(dataFrame) {     print("[calculateRegressionWithQuality]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     corrValuesModule <- c()     qualityNames <- c("quality", "quality.log", "quality.exp")     for (n1 in names(dataFrame)) {         for (n2 in qualityNames) {             if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 names1 <- append(names1, n1)                 names2 <- append(names2, n2)                 corrValues <- append(corrValues, currentModel[[4]])                 pValues <- append(pValues, currentModel$p.value)             }         }     }     corrValuesModule <- abs(corrValues)     results = data.frame(names1, names2, corrValues, pValues, corrValuesModule)     results } oldOp <- options() options(max.print = 999) whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) whiteWineDataWithLogs <- calculateExps(whiteWineDataWithLogs) whiteWineData$ID <- seq.int(nrow(whiteWineData)) whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] splittedData <- splitData(whiteWineDataWithLogsFiltered, 0.7, 123456) print(nrow(splittedData[[1]])) print(nrow(splittedData[[2]])) print(nrow(whiteWineDataWithLogsFiltered)) trainingData <- splittedData[[1]] testData <- splittedData[[2]] #regression regModel <- lm(formula = quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData) fittedData <- fitted(regModel) regRes2 <- calculateRegressionWithQuality(whiteWineDataWithLogs) regRes2Filetered <- regRes2[complete.cases(regRes2),] regRes2Filetered2 <- regRes2Filetered[(regRes2Filetered$names2 == "quality"),] regRes2FilteredOrdered <- regRes2Filetered2[with(regRes2Filetered2, order(corrValuesModule)),] #alcohol + #density.log - #chlorides.log - #volatile.acidity.log - #total.sulfur.dioxide - #fixed.acidity - testData$predicted <- predict(regModel, testData, interval = "confidence") # decision trees treeModel <- ctree(quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData, interval = "confidence")     if (NULL != transformationFunction) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData, interval = "confidence")     print(transformationFunction)     if (NULL != transformationFunction) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
testData$predictedValue
testData
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData, interval = "confidence")     print(testData$predictedValue)     print(transformationFunction)     if (NULL != transformationFunction) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
testData$predictedValue <- predict(regModel, testData, interval = "confidence")
testData$predictedValue
testData$predictedValue
testData$predictedValue.fit
testData
testData$predictedValue.fit
testData[[predictedValue.fit]]
testData[[predictedValuet]]
testData[[predictedValue]]
testData[["predictedValue"]]
testData[["predictedValue.fit"]]
testData[["predictedValue"]][[0]]
testData[["predictedValue"]][[1]]
testData[["predictedValue"]][["fit"]]
testData[["predictedValue"]]$fit
testData[["predictedValue"]]
typeof(testData[["predictedValue"]])
names(testData)
pv <- predict(dataModel, testData, interval = "confidence")
pv <- predict(regModel, testData, interval = "confidence")
pv
names(pv)
names(testData)
pv <- predict(regModel, testData, interval = "prediction")
pv
pv <- predict(regModel, testData)
pv
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     print(testData$predictedValue)     print(transformationFunction)     if (NULL != transformationFunction) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
testData$predictedValue <- predict(regModel, testData)
testData
round(testData$predictedValue)
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     print(transformationFunction)     if (NULL != transformationFunction) {         print(testData$predictedValue)         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
testData$predictedValue <- predict(regModel, testData)
tf <- round
testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)
testData$predictedValueTransformed <- tf(testData$predictedValue)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     print(transformationFunction)     if (NULL != transformationFunction) {         print(testData$predictedValue)         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     print("B")     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     print(transformationFunction)     if (NULL != transformationFunction) {         print(testData$predictedValue)         transformationFunction(testData$predictedValue)         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     print("B")     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
if (tf != NULL)
{ "df"}
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     if (!is.null(transformationFunction)) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     print("B")     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     print("A")     if (!is.null(transformationFunction)) {         print("B")         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     print("C")     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     print("A")     if (!is.null(transformationFunction)) {         print("B")         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     print("C")     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     print("D")     length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     print("A")     if (!is.null(transformationFunction)) {         print("B")         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     print("C")     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     print("D")     length(testData$predictionMinusExpected) length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0))     length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     print("A")     if (!is.null(transformationFunction)) {         print("B")         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     print("C")     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     print("D") testData$predictionMinusExpected     length(testData$predictionMinusExpected) length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0))     length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     print("A")     if (!is.null(transformationFunction)) {         print("B")         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     print("C")     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     print("D")     print(testData$predictionMinusExpected)     #length(testData$predictionMinusExpected) #length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0))  #   length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     print("A")     if (!is.null(transformationFunction)) {         print("B")         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     print("C")     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     print("D")     print(testData$predictionMinusExpected)     length(testData$predictionMinusExpected) #length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0))  #   length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     print("A")     if (!is.null(transformationFunction)) {         print("B")         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     print("C")     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     print("D")     print(testData$predictionMinusExpected)     length(testData$predictionMinusExpected)     testData$predictionMinusExpected(testData$predictionMinusExpected == 0) #length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0))  #   length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     print("A")     if (!is.null(transformationFunction)) {         print("B")         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     print("C")     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     print("D")     print(testData$predictionMinusExpected)     length(testData$predictionMinusExpected)     testData$predictionMinusExpected[testData$predictionMinusExpected == 0] #length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0))  #   length(testData$predictionMinusExpected(testData$predictionMinusExpected == 0)) / length(testData$predictionMinusExpected) }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     if (!is.null(transformationFunction)) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     print(testData$predictionMinusExpected)     l1 <- length(testData$predictionMinusExpected)     l2 <- testData$predictionMinusExpected[testData$predictionMinusExpected == 0]     l2 / l1 }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     if (!is.null(transformationFunction)) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     l1 <- length(testData$predictionMinusExpected)     l2 <- testData$predictionMinusExpected[testData$predictionMinusExpected == 0]     l2 / l1 }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     if (!is.null(transformationFunction)) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     l1 <- length(testData$predictionMinusExpected)     l2 <- testData$predictionMinusExpected[testData$predictionMinusExpected == 0]     l2 / l1 }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     if (!is.null(transformationFunction)) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     l1 <- length(testData$predictionMinusExpected) #    l2 <- testData$predictionMinusExpected[testData$predictionMinusExpected == 0]     #l2 / l1 }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     if (!is.null(transformationFunction)) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     l1 <- length(testData$predictionMinusExpected)     l2 <- length(testData$predictionMinusExpected[testData$predictionMinusExpected == 0])     #l2 / l1 }
verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData)     if (!is.null(transformationFunction)) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     l1 <- length(testData$predictionMinusExpected)     l2 <- length(testData$predictionMinusExpected[testData$predictionMinusExpected == 0])     l2 / l1 }
verifyModel(regModel, testData, "quality", round)
regVer <- verifyModel(regModel, testData, "quality", round)
treeVer <- verifyModel(treeModel, testData, "quality", round)
treeVer
regVer
treeVer <- verifyModel(treeModel, testData, "quality")
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction) {     testData$predictedValue <- predict(dataModel, testData = NULL)     if (!is.null(transformationFunction)) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     l1 <- length(testData$predictionMinusExpected)     l2 <- length(testData$predictionMinusExpected[testData$predictionMinusExpected == 0])     l2 / l1 }
regVer <- verifyModel(regModel, testData, "quality", round) treeVer <- verifyModel(treeModel, testData, "quality")
regVer <- verifyModel(regModel, testData, "quality", round)
verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction = NULL) {     testData$predictedValue <- predict(dataModel, testData)     if (!is.null(transformationFunction)) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     l1 <- length(testData$predictionMinusExpected)     l2 <- length(testData$predictionMinusExpected[testData$predictionMinusExpected == 0])     l2 / l1 }
regVer <- verifyModel(regModel, testData, "quality", round) treeVer <- verifyModel(treeModel, testData, "quality")
treeVer
regVer
predict(treeModel, testData)
regVer <- verifyModel(regModel, testData, "quality", round) treeVer <- verifyModel(treeModel, testData, "quality", round)
library(Hmisc) library(party) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])         }     }     dataFrame } calculateExps <- function(dataFrame) {     print("[calculateExps]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'exp', sep = ".")]] <- exp(dataFrame[[n]])         }     }     dataFrame } calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     names1 <- append(names1, n1)                     names2 <- append(names2, n2)                     corrValues <- append(corrValues, currentModel[[4]])                     pValues <- append(pValues, currentModel$p.value)                 }             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results } splitData <- function(inputRecords, splitRatio, seedValue) {     print("[splitData]")     print(nrow(inputRecords))     ## 75% of the sample size     smp_size <- floor(splitRatio * nrow(inputRecords))     ## set the seed to make your partition reproductible     set.seed(seedValue)     train_ind <- sample(seq_len(nrow(inputRecords)), size = smp_size)     trainData <- inputRecords[train_ind,]     testData <- inputRecords[ - train_ind,]     result <- list()     result[[1]] <- trainData     result[[2]] <- testData     result } calculateRegressionWithQuality <- function(dataFrame) {     print("[calculateRegressionWithQuality]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     corrValuesModule <- c()     qualityNames <- c("quality", "quality.log", "quality.exp")     for (n1 in names(dataFrame)) {         for (n2 in qualityNames) {             if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 names1 <- append(names1, n1)                 names2 <- append(names2, n2)                 corrValues <- append(corrValues, currentModel[[4]])                 pValues <- append(pValues, currentModel$p.value)             }         }     }     corrValuesModule <- abs(corrValues)     results = data.frame(names1, names2, corrValues, pValues, corrValuesModule)     results } oldOp <- options() options(max.print = 999) whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) whiteWineDataWithLogs <- calculateExps(whiteWineDataWithLogs) whiteWineData$ID <- seq.int(nrow(whiteWineData)) whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] splittedData <- splitData(whiteWineDataWithLogsFiltered, 0.7, 123456) print(nrow(splittedData[[1]])) print(nrow(splittedData[[2]])) print(nrow(whiteWineDataWithLogsFiltered)) trainingData <- splittedData[[1]] testData <- splittedData[[2]] #regression regModel <- lm(formula = quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData) fittedData <- fitted(regModel) regRes2 <- calculateRegressionWithQuality(whiteWineDataWithLogs) regRes2Filetered <- regRes2[complete.cases(regRes2),] regRes2Filetered2 <- regRes2Filetered[(regRes2Filetered$names2 == "quality"),] regRes2FilteredOrdered <- regRes2Filetered2[with(regRes2Filetered2, order(corrValuesModule)),] #alcohol + #density.log - #chlorides.log - #volatile.acidity.log - #total.sulfur.dioxide - #fixed.acidity - testData$predicted <- predict(regModel, testData, interval = "confidence") # decision trees treeModel <- ctree(quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData) print(treeModel) #plot(treeModel) verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction = NULL) {     testData$predictedValue <- predict(dataModel, testData)     if (!is.null(transformationFunction)) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     l1 <- length(testData$predictionMinusExpected)     l2 <- length(testData$predictionMinusExpected[testData$predictionMinusExpected == 0])     l2 / l1 } regVer <- verifyModel(regModel, testData, "quality", round) treeVer <- verifyModel(treeModel, testData, "quality", round)
regVer <- verifyModel(regModel, testData, "quality", round) treeVer <- verifyModel(treeModel, testData, "quality", round)
treeModel2 <- ctree(quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide, data = trainingData)
treeVer2 <- verifyModel(treeModel, testData, "quality", round)
treeVer2
treeVer
treeVer2 <- verifyModel(treeModel2, testData, "quality", round)
treeVer2
treeModel2 <- ctree(quality ~ density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData) treeVer2 <- verifyModel(treeModel2, testData, "quality", round)
treeModel2 <- ctree(quality ~ density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData) treeVer2 <- verifyModel(treeModel2, testData, "quality", round) treeVer2
treeModel2 <- ctree(quality ~ alcohol + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData) treeVer2 <- verifyModel(treeModel2, testData, "quality", round) treeVer2
treeModel2 <- ctree(quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData) treeVer2 <- verifyModel(treeModel2, testData, "quality", round) treeVer2
treeModel2 <- ctree(quality ~ alcohol + density.log + chlorides.log  + total.sulfur.dioxide + fixed.acidity, data = trainingData) treeVer2 <- verifyModel(treeModel2, testData, "quality", round) treeVer2
treeModel2 <- ctree(quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + fixed.acidity, data = trainingData) treeVer2 <- verifyModel(treeModel2, testData, "quality", round) treeVer2
names(trainingData)
treeModel3 <- ctree(quality ~ ., data = trainingData) treeVer3 <- verifyModel(treeModel3, testData, "quality", round) treeVer3
regModel2 <- lm(formula = quality ~ ., data = trainingData) regVer3 <- verifyModel(regVer3, testData, "quality", round) regVer3
regModel3 <- lm(formula = quality ~ ., data = trainingData) regVer3 <- verifyModel(regModel3, testData, "quality", round) regVer3
regModel3 <- lm(formula = quality ~ ., data = trainingData)
treeModel3 <- ctree(quality ~ ., data = trainingData) treeVer3 <- verifyModel(treeModel3, testData, "quality", round) treeVer3
library(Hmisc) library(party) calculateLogs <- function(dataFrame) {     print("[calculateLogs]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'log', sep = ".")]] <- log(dataFrame[[n]])         }     }     dataFrame } calculateExps <- function(dataFrame) {     print("[calculateExps]")     for (n in names(dataFrame)) {         if (!endsWith(n, ".log") && !endsWith(n, ".exp")) {             dataFrame[[paste(n, 'exp', sep = ".")]] <- exp(dataFrame[[n]])         }     }     dataFrame } calculateRegression <- function(dataFrame) {     print("[calculateRegression]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     for (n1 in names(dataFrame)) {         for (n2 in names(dataFrame)) {             if (n1 < n2) {                 if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                     print(n1)                     print(n2)                     dataFrame[[n1]]                     #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                     currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                     #print(currentModel)                     names1 <- append(names1, n1)                     names2 <- append(names2, n2)                     corrValues <- append(corrValues, currentModel[[4]])                     pValues <- append(pValues, currentModel$p.value)                 }             }         }     }     results = data.frame(names1, names2, corrValues, pValues)     results } splitData <- function(inputRecords, splitRatio, seedValue) {     print("[splitData]")     print(nrow(inputRecords))     ## 75% of the sample size     smp_size <- floor(splitRatio * nrow(inputRecords))     ## set the seed to make your partition reproductible     set.seed(seedValue)     train_ind <- sample(seq_len(nrow(inputRecords)), size = smp_size)     trainData <- inputRecords[train_ind,]     testData <- inputRecords[ - train_ind,]     result <- list()     result[[1]] <- trainData     result[[2]] <- testData     result } calculateRegressionWithQuality <- function(dataFrame) {     print("[calculateRegressionWithQuality]")     names1 <- c()     names2 <- c()     corrValues <- c()     pValues <- c()     corrValuesModule <- c()     qualityNames <- c("quality", "quality.log", "quality.exp")     for (n1 in names(dataFrame)) {         for (n2 in qualityNames) {             if (!startsWith(n1, n2) && !startsWith(n2, n1)) {                 print(n1)                 print(n2)                 dataFrame[[n1]]                 #currentModel = lm(dataFrame[[n1]] ~ dataFrame[[n2]], data = dataFrame)                 currentModel = cor.test(dataFrame[[n1]], dataFrame[[n2]], method = "pearson")                 #print(currentModel)                 names1 <- append(names1, n1)                 names2 <- append(names2, n2)                 corrValues <- append(corrValues, currentModel[[4]])                 pValues <- append(pValues, currentModel$p.value)             }         }     }     corrValuesModule <- abs(corrValues)     results = data.frame(names1, names2, corrValues, pValues, corrValuesModule)     results } oldOp <- options() options(max.print = 999) whiteWineData <- read.csv("d:/GitHub/Data/Dane/wine-quality/winequality-white.csv", header = TRUE, sep = ";", dec = ".") whiteWineDataCopy <- whiteWineData whiteWineDataWithLogs <- calculateLogs(whiteWineData) whiteWineDataWithLogs <- calculateExps(whiteWineDataWithLogs) whiteWineData$ID <- seq.int(nrow(whiteWineData)) whiteWineDataWithLogsFiltered <- whiteWineDataWithLogs[complete.cases(whiteWineDataWithLogs),] splittedData <- splitData(whiteWineDataWithLogsFiltered, 0.7, 123456) print(nrow(splittedData[[1]])) print(nrow(splittedData[[2]])) print(nrow(whiteWineDataWithLogsFiltered)) trainingData <- splittedData[[1]] testData <- splittedData[[2]] #regression regModel <- lm(formula = quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData) fittedData <- fitted(regModel) regRes2 <- calculateRegressionWithQuality(whiteWineDataWithLogs) #regRes2Filetered <- regRes2[complete.cases(regRes2),] #regRes2Filetered2 <- regRes2Filetered[(regRes2Filetered$names2 == "quality"),] #regRes2FilteredOrdered <- regRes2Filetered2[with(regRes2Filetered2, order(corrValuesModule)),] #alcohol + #density.log - #chlorides.log - #volatile.acidity.log - #total.sulfur.dioxide - #fixed.acidity - testData$predicted <- predict(regModel, testData, interval = "confidence") # decision trees treeModel <- ctree(quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData) print(treeModel) #plot(treeModel) verifyModel <- function(dataModel, testData, predictedColumn, transformationFunction = NULL) {     testData$predictedValue <- predict(dataModel, testData)     if (!is.null(transformationFunction)) {         testData$predictedValueTransformed <- transformationFunction(testData$predictedValue)     }     else {         testData$predictedValueTransformed <- testData$predictedValue     }     testData$predictionMinusExpected <- testData$predictedValueTransformed - testData[[predictedColumn]]     l1 <- length(testData$predictionMinusExpected)     l2 <- length(testData$predictionMinusExpected[testData$predictionMinusExpected == 0])     l2 / l1 } regVer <- verifyModel(regModel, testData, "quality", round) treeVer <- verifyModel(treeModel, testData, "quality", round) treeModel2 <- ctree(quality ~ alcohol + density.log + chlorides.log + volatile.acidity.log + total.sulfur.dioxide + fixed.acidity, data = trainingData) treeVer2 <- verifyModel(treeModel2, testData, "quality", round) treeVer2 treeModel3 <- ctree(quality ~ ., data = trainingData) treeVer3 <- verifyModel(treeModel3, testData, "quality", round) treeVer3
